# 72. 编辑距离
给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

1. 插入一个字符  
2. 删除一个字符  
3. 替换一个字符  
 
##### 示例 1：

输入：word1 = "horse", word2 = "ros"  
输出：3  
解释：  
horse -> rorse (将 'h' 替换为 'r')  
rorse -> rose (删除 'r')  
rose -> ros (删除 'e')  
##### 示例 2：  

输入：word1 = "intention", word2 = "execution"  
输出：5  
解释：  
intention -> inention (删除 't')  
inention -> enention (将 'i' 替换为 'e')  
enention -> exention (将 'n' 替换为 'x')  
exention -> exection (将 'n' 替换为 'c')  
exection -> execution (插入 'u')  

### 相似题目
583. 两个字符串的删除操作  

### 动态规划
1. 数组含义：dp[i][j]——word1的[0...i-1]变换到word2的[0...j-1]的编辑距离数目  
2. 递推关系：  
  2.1. 如果word1[i-1] == word2[j-1], 那么从word1的[0...i]变换到word2的[0...j]，等同于从word1的[0...i-1]变换到word2的[0...j-1]，因为最后一位相同，不需要做任何变换  
  2.2. 如果word1[i-1] != word2[j-1]，那么从word1的[0...i]变换到word2的[0...j]，有三种情况：  
    2.2.1. word1[0...i]删除第i个字符，变换到word2[0...j], 此时dp[i][j] = dp[i-1][j]+1  
    2.2.2. word2[0...j]删除第j个字符，变换到word1[0...i], 此时dp[i][j] = dp[i][j-1]+1  
    2.2.3. word1[0...i]替换第i个字符，变换到word2[0...j], 此时dp[i][j] = dp[i-1][j-1]+1  
3. 初始化：  
  3.1. dp[i][0] = i, 代表从word1[0...i]变换到空串，需要的编辑距离是i（删除i次）  
  3.2. dp[0][j] = j, 同理，代表从word2[0...j]变换到空串，需要的编辑距离是j（删除j次）  
```
class Solution {
public:
    int minDistance(string word1, string word2) {
        int len1 = word1.length();
        int len2 = word2.length();
        vector<vector<int>>dp(len1+1, vector<int>(len2+1, 0));
        dp[0][0] = 0;

        for(int i = 0; i<=len1;i++)
        {
            dp[i][0] = i;
        }
        for(int j = 0;j<=len2;j++)
        {
            dp[0][j] = j;
        }

        for(int i = 1;i<=len1;i++)
        {
            for(int j = 1;j<=len2;j++)
            {
                if(word1[i-1] == word2[j-1])
                {
                    dp[i][j] = dp[i-1][j-1];
                }
                else
                {
                    dp[i][j] = 1 + min(dp[i-1][j], min(dp[i][j-1],dp[i-1][j-1]));
                }
            }
        }
        return dp[len1][len2];
    }
};
```

