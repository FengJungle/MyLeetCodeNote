# 746. 使用最小花费爬楼梯
数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。  
每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。  
请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。  

##### 示例 1：
  
输入：cost = [10, 15, 20]  
输出：15  
解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。  
##### 示例 2：

输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]  
输出：6  
解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。  

### 解法1：动态规划
* dp[i]——爬到第i级的最小花费是dp[i]
* 递推关系：爬到第i级有两种方法，一种是从第i-1级往上爬1级，另一种是从第i-2级往上爬两级。选择哪一种方法取决于哪一种方法的花费较少。所以递推关系如下：
```
dp[i] = cost[i] + min(dp[i-1], dp[i-2]);
```
* 代码如下:
```
int minCostClimbingStairs(vector<int>& cost) {
    int n = cost.size();
    if(n == 1) return cost[0];
    if(n == 2) return min(cost[0], cost[1]);
    int * dp = new int[n];
    dp[0] = cost[0];
    dp[1] = cost[1];
    for(int i = 2;i<n;i++)
    {
        dp[i] = cost[i] + min(dp[i-1], dp[i-2]);
    }
    return min(dp[n-1], dp[n-2]);
}
```