# 剑指 Offer 46. 把数字翻译成字符串
给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

##### 示例 1:
  
输入: 12258  
输出: 5  
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"  

### 解法1：动态规划
为方便取值，先把传入的整数转成字符串，然后再使用动态规划：  
#### 1. dp[i]:数字从左起0~第i位，一共有dp[i]种翻译方法
#### 2. 递推关系：
对于dp[i]:
* 1) 如果第i-1位数字是0，那么第i-1位不可能和第i位合在一起翻译，所以此时dp[i] = dp[i-1]
* 2) 如果第i-1位数字是1，那么第i-1位和第i位可以单独翻译(dp[i-1])，也可以一起翻译(dp[i-2])，此时dp[i] = dp[i-1]+dp[i-2];
* 3) 如果第i-2位数字是2，并且第i位数字范围位于0~5，那么同第二种情况，dp[i] = dp[i-1]+dp[i-2];
* 4) 其他情况，比如38，只能分开翻译，此时dp[i] = dp[i-1]
##### 3. 初始化：显然dp[0] = 1，而dp[1]的值取决于第0位和第1位的取值，分类讨论如同上述递推关系：
```
if(str[0]=='0')
{
    dp[1] = 1;
}
else if(str[0] == '1' || (str[0] == '2' && str[1] <='5')) 
{
    dp[1] = 2;
}
else
{
    dp[1] = 1;
}
```
##### 4. 最后上代码：
```
int translateNum(int num) {
    if(num <= 9) return 1;
    if(num <= 25) return 2;
    string str = to_string(num);
    vector<int>dp(str.length(), 0);
    dp[0] = 1;
    if(str[0]=='0') dp[1] = 1;
    else if(str[0] == '1' || (str[0] == '2' && str[1] <='5')) dp[1] = 2;
    else dp[1] = 1;

    for(int i = 2;i<str.length();i++)
    {
        if(str[i-1] == '0')
        {
            dp[i] = dp[i-1];
        }
        else if(str[i-1] == '1' || (str[i-1] == '2' && str[i] <= '5'))
        {
            dp[i] = dp[i-1]+dp[i-2];
        }
        else
        {
            dp[i] = dp[i-1];
        }
    }
    
    return dp[str.length()-1];
}
```
