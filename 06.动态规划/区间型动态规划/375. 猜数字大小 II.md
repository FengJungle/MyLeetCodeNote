# 375. 猜数字大小 II

我们正在玩一个猜数游戏，游戏规则如下：  
  
我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。  
每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。  
然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。  

##### 示例:  
  
n = 10, 我选择了8.  
  
第一轮: 你猜我选择的数字是5，我会告诉你，我的数字更大一些，然后你需要支付5块。  
第二轮: 你猜是7，我告诉你，我的数字更大一些，你支付7块。  
第三轮: 你猜是9，我告诉你，我的数字更小一些，你支付9块。  

游戏结束。8 就是我选的数字。  
  
你最终要支付 5 + 7 + 9 = 21 块钱。  
给定 n ≥ 1，计算你至少需要拥有多少现金才能确保你能赢得这个游戏。  

### 方法1：区间型动态规划

#### 区间型动态规划特点
区间型动态规划题目的最优解一般表示为dp[i][j]，表示在区间[i, j]上的最优解。通常对某个区间[ i,  j ]两端操作，根据dp[i+1][j]或者dp[i][j-1]来递推下一个状态（即递推关系，或者状态转换方程）：
```
dp[i][j] = temp + max/min(dp[i+1][j], dp[i][j-1])
```
因为区间是从两端通过i+1或者j-1来不断缩小，所以在遍历的时候不能够像平常的从头到尾遍历，而是以区间的长度len为循环变量，在不同的长度区间里枚举所有可能的状态，并从中选取最优解。  

所以，可以从区间类问题里提炼出通俗的解法：
```
for (int len = 2; len < n; len++){
	for (int i = 0; i < n - len; i++){
		int j = i + len;
		for (int k = i + 1; k < j; k++){
			dp[i][j] = temp + max/min(dp[i+1][j], dp[i][j-1]);
		}
	}
}
```
上述代码的递推关系（状态转移方程）只是一个示例，在具体题目里应根据题目要求做适当变换。  
最后返回的，当然应该是在整个区间长度里[ 0, n-1 ]的最优解，即dp[0][n-1].

#### 本题解法
（1）明确数组元素代表的含义  
根据前述区间型动态规划的思想，很容易理解dp[i][j]代表在区间[i, j]中最优解。

（2）寻找递推关系  

假设 k （i+1 < k < j-1）是 [i...j] 中最后猜的数字，则
```
dp[i][j] = min {for k = range(i+1, j -1) k + max(dp[i][k-1] , dp[k+1][j])}
```
（3）数组初始化

区间里只有一个数字时，肯定能够猜对，且无需花费，所以dp[i][i] = 0.

（4）代码
```
class Solution {
public:
    int getMoneyAmount(int n) {
        if(n <= 3)
        {
            return n-1;
        }
        vector<vector<int>>dp(n+1, vector<int>(n+1, 0));
        for(int i = 1; i <= n;i++)
        {
            dp[i][i] = 0;
        }
        for(int len = 2; len <= n; len++)
        {
            for(int i = 1; i <= n - len + 1; i++)
            {
                int minCost = INT_MAX;
                int j = i + len - 1;
                for(int k = i; k < j; k++)
                {
                    minCost = min(minCost, k + max(dp[i][k-1], dp[k+1][j]));
                }
                dp[i][j] = minCost;
            }
        }
        return dp[1][n];
    }
};
```

### 方法2：二分法（超时）
一碰到这个题目，很容易想到二分法，用两个变量low和high标记区间两端位置，不断取(low+high)/2将每个区间分为两个子区间。本题要求“确保你能赢得这个游戏”，也就是说在最坏情况下也能赢。

所以依据二分法的思想，不断缩小每个区间，枚举每个区间的花费。由于要求最坏情况，所以左右两个区间，应取最大花费。最坏情况下，要尽可能少花费，所以最终要取所有最坏情况下的最小花费值。由此可以写下如下代码：
```
int getCost(int low, int high){
	int res = 0;
	int minCost = 65535;
	if (low >= high){
		return res;
	}
	for (int i = (low + high) / 2; i <= high; i++){
		// 取最大值——最坏情况都能赢，才是确保能够赢
		res = i + max(getCost(low, i - 1), getCost(i + 1, high));
		minCost = min(minCost, res);
	}
	return minCost;
}
int getMoneyAmount(int n) {
	return getCost(1, n);
}
```