一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

##### 示例 1：

输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]
##### 示例 2：

输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]
 
##### 限制：  
  
2 <= nums.length <= 10000  

### 解法1： 异或
* 1. 如果一个数组中，只有一个元素只出现一次，而别的元素均出现两次，要找到这个元素，只要将所有元素逐个异或，则得到该元素。
* 2. 现在我们需要把题目所述的元素分成两个数组，使得两个只出现一次的元素被分别放在两个数组中，而两个数组中别的元素均出现两次。这时候再用第一步的方法即可。
* **如何分成两个数组呢**？
异或的结果表示两个数字有哪些bit位不同，不同则为1，相同则为0。所以： 
- 1. 所有元素异或，结果其实是两个只出现一次的数的异或的结果
- 2. 找到异或的结果中，第一个bit为1的位置
- 3. 根据这个bit为1的位置，将原数组划分为两个子数组：该bit为1的放在一个数组里；该bit为0的放在另一个数组里。
- 4. 在每个数组里找到只出现一次的数即可
```
vector<int> singleNumbers(vector<int>& nums) {
    vector<int> ret;
    // 1. 所有元素的异或的结果保存在tmp
    int tmp = 0;
    for(int i = 0;i<nums.size();i++)
    {
        tmp ^= nums[i];
    }
    // 2. tmp是两个只出现1此的元素的异或的结果，查找bit为1的最低位
    int bit = 0;
    int cnt = 1;
    while((tmp&cnt) == 0)
    {
        bit++;
        cnt <<= 1;
    }
    // 3. 根据bit为1，将原数组分为两组：一组的数组其第bit位为1，另一个的元素其bit位为0
    int num1 = 0;
    int num2 = 0;
    for(int i = 0;i<nums.size();i++)
    {
        if((nums[i] & cnt) == 0)
        {
            num1 ^= nums[i];
        }
        else
        {
            num2 ^= nums[i];
        }
    }
    ret.push_back(num1);
    ret.push_back(num2);
    return ret;
}
```